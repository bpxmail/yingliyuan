<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>应力圆</title>
    <style>
        canvas {
            touch-action: none;
            border: 1px solid black;
        }
    </style>
</head>

<body>
    <canvas id="myCanvas">canvas not supported</canvas>
    <p id="pid">α-β-γ-δ-ε-ζ-η-θ-ι-κ-λ-μ-ν-ξ-ο-π-ρ-σ-τ-υ-φ-χ-ψ-ω</p>
    <script>
        var canvas = document.getElementById("myCanvas");
        var ctx = canvas.getContext("2d");
        var p = document.getElementById("pid");
        // 在手机上宽度300，在PC上宽度450
        if (isMobile()) canvas.width = 300; else canvas.width = 450;
        canvas.height = canvas.width * 9 / 5;
        let w = canvas.width;
        let h = canvas.height;

        let ori = { x: w / 8, y: h / 6 }; // 坐标轴原点
        let circ = { x: w / 2, y: ori.y }; // 圆心坐标
        let arrow = w / 40; // 箭头大小
        let r = h * 2 / 15; // 半径

        // 鼠标拖动功能
        var dragging = false;
        let angle = 30; // 移动点与横轴夹角
        let angle0 = 30; // 初始角度
        let pt = { x: 0, y: 0 }; // 移动点

        function draw() {
            ctx.clearRect(0, 0, w, h); // 清除画布

            // 绘制分隔线
            ctx.beginPath();
            ctx.moveTo(0, h / 3);
            ctx.lineTo(w, h / 3);
            ctx.moveTo(0, h * 2 / 3);
            ctx.lineTo(w, h * 2 / 3);
            ctx.stroke();

            if (isMobile()) ctx.font = "bolder 14px 'Times New Roman'";
            else ctx.font = "bolder 18px 'Times New Roman";
            ctx.textAlign = "center";
            ctx.fillText("请拖动红点以观察不同角度斜面上的应力", w / 2, h / 40);
            // ctx.font = "bolder italic 18px 'Times New Roman'";
            if (isMobile()) ctx.font = "bolder italic 12px 'Times New Roman'";
            else ctx.font = "bolder italic 20px 'Times New Roman'";
            ctx.lineWidth = 2;
            let t = { x: 0, y: 0 }; // 临时变量

            pt.x = circ.x + r * Math.cos(a2r(angle));
            pt.y = ori.y - r * Math.sin(a2r(angle));
            // 绘制坐标轴
            ctx.beginPath();
            ctx.moveTo(w / 20, ori.y);
            ctx.lineTo(w - w / 20, ori.y);
            ctx.moveTo(ori.x, h * 3 / 10);
            ctx.lineTo(ori.x, h / 30);
            ctx.stroke();
            // 绘制箭头
            drawarrow({ x: w - w / 20, y: ori.y }, arrow, 0);
            drawarrow({ x: ori.x, y: h / 30 }, arrow, 90);
            // 绘制坐标轴文字
            ctx.fillText("σ", w - w / 20 - 10, ori.y + 20);
            ctx.fillText("σ1", circ.x + r + 20, ori.y + 20);
            ctx.fillText("σ2", circ.x - r - 15, ori.y + 20);
            ctx.fillText("τ", ori.x + 10, h / 30 + 10);
            ctx.fillText("2α0", circ.x + r / 2, circ.y - r / 20);
            if (angle != angle0) ctx.fillText("2α", circ.x + r / 4, circ.y - r / 3);
            // 绘制圆
            ctx.save(); //save1
            ctx.translate(circ.x, circ.y);
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, 2 * Math.PI);
            ctx.stroke();
            // 绘制圆弧1
            ctx.beginPath();
            ctx.arc(0, 0, r / 4, 0, a2r(-angle0), true);
            ctx.stroke();
            // 绘制圆弧2
            ctx.beginPath();
            ctx.arc(0, 0, r / 3, a2r(-angle0), a2r(-angle), true);
            ctx.stroke();
            // 绘制主应力点
            ctx.beginPath();
            ctx.save();
            ctx.fillStyle = 'blue';
            ctx.arc(r, 0, 5, 0, 2 * Math.PI);
            ctx.arc(-r, 0, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
            // 绘制虚线
            ctx.beginPath();
            ctx.save();
            ctx.strokeStyle = 'green';
            ctx.setLineDash([6, 6]);
            ctx.rotate(a2r(-angle0));
            ctx.moveTo(-r, 0);
            ctx.lineTo(r, 0);
            ctx.stroke();
            ctx.restore();
            // 绘制移动虚线
            ctx.beginPath();
            ctx.save();
            ctx.setLineDash([4, 5]);
            ctx.moveTo(ori.x - circ.x, - r * Math.sin(a2r(angle)));
            ctx.lineTo(r * Math.cos(a2r(angle)), - r * Math.sin(a2r(angle)));
            ctx.lineTo(r * Math.cos(a2r(angle)), 0);
            ctx.stroke();
            ctx.restore();
            // 绘制半径
            ctx.beginPath();
            ctx.save();
            ctx.rotate(a2r(-angle));
            ctx.moveTo(0, 0);
            ctx.lineTo(r, 0);
            ctx.stroke();
            ctx.restore();
            // 绘制移动点
            ctx.beginPath();
            ctx.save();
            ctx.fillStyle = 'red';
            ctx.rotate(a2r(-angle));
            ctx.arc(r, 0, 10, 0, 2 * Math.PI);
            if (dragging) { ctx.shadowBlur = 10; ctx.shadowColor = 'navy'; }
            else ctx.shadowBlur = 0;
            ctx.fill();
            ctx.restore();
            ctx.restore(); //restore1


            p.textContent = w;
        }

        // 绘制箭头，angle为箭头方向，逆时针为正
        function drawarrow(pt, size, angle) {
            ctx.save();
            ctx.translate(pt.x, pt.y);
            ctx.rotate(a2r(-angle)); // 逆时针为正
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-size, -size / 2);
            ctx.lineTo(-size, size / 2);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        // 角度转弧度
        function a2r(angle) {
            return angle * Math.PI / 180;
        }

        // 判断当前设备是否为移动设备
        function isMobile() {
            const userAgent = navigator.userAgent.toLowerCase();
            return /iphone|ipod|android|blackberry|windows phone|mobile/i.test(userAgent);
        }

        canvas.addEventListener("pointerdown", function (event) {
            // 检查鼠标是否点击在移动点附近
            let dx = event.offsetX - pt.x;
            let dy = event.offsetY - pt.y;
            if (Math.sqrt(dx * dx + dy * dy) < 15) {
                dragging = true;
            }
        });

        canvas.addEventListener('pointermove', (event) => {
            event.preventDefault(); // 防止默认行为
            if (dragging) {
                angle = -Math.atan2(event.offsetY - circ.y, event.offsetX - circ.x) * 180 / Math.PI;
                angle = ((angle - angle0) % 360 + 360) % 360 + angle0;
                angle = Math.round(angle * 10) / 10;
                p.textContent = angle;
            }
            draw(); // 重绘
        });

        canvas.addEventListener('pointerup', (event) => {
            dragging = false;
            draw(); // 重绘
        });

        canvas.addEventListener('pointerleave', (event) => {
            dragging = false;
            draw(); // 重绘
        });

        draw();

    </script>
</body>

</html>
