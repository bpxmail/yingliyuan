<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>应力圆</title>
    <style>
        canvas {
            touch-action: none;
            border: 1px solid black;
        }
    </style>
</head>

<body>
    <canvas id="canvasid" width="500" height="600">canvas not supported</canvas>
    <p id="pid">debug-σ</p>
    <script>
        var canvas = document.getElementById("canvasid");
        var ctx = canvas.getContext("2d");
        var p = document.getElementById("pid");

        let Xstart = { x: 50, y: 150 };
        let Xend = { x: 450, y: 150 };
        let Ystart = { x: 150, y: 250 };
        let Yend = { x: 150, y: 50 };
        let circ = { x: 300, y: Xstart.y }; // 圆心坐标
        let arrow = 10; // 箭头大小
        let r = 100; // 半径
        let log = 'log';

        // 鼠标拖动功能
        var dragging = false;
        // 初始角度
        let angle0 = 30;
        let angle = 30;
        let pt = { x: 0, y: 0 }; // 移动点

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // 清除画布
            ctx.font = "bolder 20px 'Times New Roman'";
            ctx.fillText("请拖动红点以观察不同角度斜面上的应力", 70, 20);
            ctx.font = "bolder italic 20px 'Times New Roman'";
            ctx.lineWidth = 2;
            pt.x = circ.x + r * Math.cos(a2r(angle));
            pt.y = Xend.y - r * Math.sin(a2r(angle));
            let t = { x: 0, y: 0 }; // 临时变量

            // 绘制坐标轴
            ctx.beginPath();
            ctx.moveTo(Xstart.x, Xstart.y);
            ctx.lineTo(Xend.x, Xend.y);
            ctx.moveTo(Ystart.x, Ystart.y);
            ctx.lineTo(Yend.x, Yend.y);
            ctx.stroke();
            // 绘制箭头
            drawarrow(Xend, arrow, 0);
            drawarrow(Yend, arrow, 90);
            // 绘制坐标轴文字
            ctx.fillText("σ", Xend.x - 10, Xend.y + 20);
            ctx.fillText("τ", Yend.x + 10, Yend.y + 10);
            ctx.fillText("2α0", circ.x + r / 2, circ.y - r / 12);
            if (angle != angle0) ctx.fillText("2α", circ.x + r / 4, circ.y - r / 4);
            // 绘制圆
            ctx.save(); //save1
            ctx.translate(circ.x, circ.y);
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, 2 * Math.PI);
            ctx.stroke();
            // 绘制圆弧1
            ctx.beginPath();
            ctx.arc(0, 0, r / 4, 0, a2r(-angle0), true);
            ctx.stroke();
            // 绘制圆弧2
            ctx.beginPath();
            ctx.arc(0, 0, r / 3, a2r(-angle0), a2r(-angle), true);
            ctx.stroke();
            // 绘制虚线
            ctx.beginPath();
            ctx.save();
            ctx.strokeStyle = 'green';
            ctx.setLineDash([6, 6]);
            ctx.rotate(a2r(-angle0));
            ctx.moveTo(-r, 0);
            ctx.lineTo(r, 0);
            ctx.stroke();
            ctx.restore();
            // 绘制移动虚线
            ctx.beginPath();
            ctx.save();
            ctx.setLineDash([3, 5]);
            ctx.moveTo(Yend.x - circ.x, - r * Math.sin(a2r(angle)));
            ctx.lineTo(r * Math.cos(a2r(angle)), - r * Math.sin(a2r(angle)));
            ctx.lineTo(r * Math.cos(a2r(angle)), 0);
            ctx.stroke();
            ctx.restore();
            // 绘制半径
            ctx.beginPath();
            ctx.save();
            ctx.rotate(a2r(-angle));
            ctx.moveTo(0, 0);
            ctx.lineTo(r, 0);
            ctx.stroke();
            ctx.restore();
            // 绘制移动点
            ctx.beginPath();
            ctx.save();
            ctx.fillStyle = 'red';
            ctx.rotate(a2r(-angle));
            ctx.arc(r, 0, 10, 0, 2 * Math.PI);
            if (dragging) { ctx.shadowBlur = 10; ctx.shadowColor = 'navy'; }
            ctx.fill();
            ctx.restore();
            ctx.restore(); //restore1 

            let squl = 180; // 单元体大小
            let squc = { x: canvas.width / 2, y: Xstart.y + 300 };// 单元体中心坐标
            // 绘制单元体
            ctx.save(); // save2
            ctx.translate(squc.x, squc.y);
            ctx.beginPath();
            ctx.moveTo(- squl / 2, - squl / 2);
            ctx.lineTo(squl / 2, - squl / 2);
            ctx.lineTo(+ squl / 2, + squl / 2);
            ctx.lineTo(- squl / 2, + squl / 2);
            ctx.closePath();
            ctx.stroke();
            // 绘制坐标轴
            ctx.beginPath
            ctx.moveTo(0, - squl / 2);
            ctx.lineTo(0, - squl);
            ctx.moveTo(squl / 2, 0);
            ctx.lineTo(squl, 0);
            ctx.stroke();
            drawarrow({ x: 0, y: 0 - squl }, arrow, 90);
            drawarrow({ x: 0 + squl, y: 0 }, arrow, 0);
            ctx.rotate(a2r(-angle + angle0) / 2); // 斜面法向量
            ctx.moveTo(0, 0);
            ctx.lineTo(squl, 0);
            ctx.stroke();
            drawarrow({ x: squl, y: 0 }, arrow, 0);
            ctx.rotate(a2r(angle - angle0) / 2);
            ctx.fillText("x", squl - 10, + 20);
            ctx.fillText("y", 10, - squl + 10);
            ctx.fillText("σx", squl * 3 / 4 - 20, 20);
            ctx.fillText("σy", 10, - squl * 3 / 4 + 10);
            ctx.fillText("τxy", squl * 3 / 4 - 30, 50);
            ctx.fillText("α", squl - 20, -10);
            // 绘制圆弧
            ctx.beginPath();
            ctx.arc(0, 0, squl * 5 / 6, 0, a2r(angle0 - angle) / 2, true);
            ctx.stroke();
            // 绘制单元体应力及箭头
            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = 'rgb(0,150,150)';
            ctx.moveTo(- squl / 2 - 10, - squl / 4);
            ctx.lineTo(- squl / 2 - 10, squl / 4);
            ctx.moveTo(squl / 2 + 10, - squl / 4);
            ctx.lineTo(squl / 2 + 10, squl / 4);
            ctx.moveTo(- squl / 4, - squl / 2 - 10);
            ctx.lineTo(squl / 4, - squl / 2 - 10);
            ctx.moveTo(- squl / 4, squl / 2 + 10);
            ctx.lineTo(squl / 4, squl / 2 + 10);
            ctx.moveTo(- squl / 2, 0);
            ctx.lineTo(- squl * 3 / 4, 0);
            ctx.moveTo(squl / 2, 0);
            ctx.lineTo(squl * 3 / 4, 0);
            ctx.moveTo(0, - squl / 2);
            ctx.lineTo(0, - squl * 3 / 4);
            ctx.moveTo(0, 0 + squl / 2);
            ctx.lineTo(0, 0 + squl * 3 / 4);
            ctx.rotate(a2r(-angle + angle0) / 2);
            ctx.moveTo(0, 0); // 斜面正应力
            ctx.lineTo(squl * 0.4, 0);
            ctx.moveTo(10, -squl / 4); // 斜面剪应力
            ctx.lineTo(10, squl / 4);
            ctx.rotate(a2r(angle - angle0) / 2);
            ctx.stroke();
            ctx.fillStyle = 'rgb(0,150,150)';
            drawarrow({ x: - squl / 2 - 10, y: - squl / 4 }, arrow, 90);
            drawarrow({ x: squl / 2 + 10, y: squl / 4 }, arrow, -90);
            drawarrow({ x: - squl / 4, y: - squl / 2 - 10 }, arrow, 180);
            drawarrow({ x: squl / 4, y: squl / 2 + 10 }, arrow, 0);
            drawarrow({ x: - squl * 3 / 4, y: 0 }, arrow, 180);
            drawarrow({ x: squl * 3 / 4, y: 0 }, arrow, 0);
            drawarrow({ x: 0, y: - squl * 3 / 4 }, arrow, 90);
            drawarrow({ x: 0, y: squl * 3 / 4 }, arrow, -90);
            ctx.rotate(a2r(-angle + angle0) / 2);
            drawarrow({ x: squl * 0.4, y: 0 }, arrow, 0);
            drawarrow({ x: 10, y: squl / 4 }, arrow, -90);
            ctx.rotate(a2r(angle - angle0) / 2);
            ctx.restore();
            // 绘制斜面
            ctx.beginPath();
            ctx.save();
            ctx.rotate(a2r(-angle + angle0) / 2);
            ctx.save();
            ctx.lineWidth = 4;
            ctx.moveTo(0, -squl * 0.4); // 斜面
            ctx.lineTo(0, squl * 0.4);
            ctx.stroke();
            ctx.restore();
            ctx.beginPath(); // 斜面阴影
            for (let i = -0.38; i < 0.35; i += 0.1) {
                ctx.moveTo(0, squl * i);
                ctx.lineTo(-10, squl * i + 10);
            }
            ctx.stroke();
            ctx.restore();
            ctx.restore(); // restore2
        }

        // 绘制箭头，angle为箭头方向，逆时针为正
        function drawarrow(pt, size, angle) {
            ctx.save();
            ctx.translate(pt.x, pt.y);
            ctx.rotate(a2r(-angle)); // 逆时针为正
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-size, -size / 2);
            ctx.lineTo(-size, size / 2);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        // 角度转弧度
        function a2r(angle) {
            return angle * Math.PI / 180;
        }

        // 自定义点的旋转函数，逆时针旋转为正
        function rotate(c, pt, angle) {
            // 转换角度为弧度。由于图像y轴向下，所以添加符号
            const radians = -angle * Math.PI / 180;
            // 计算新的坐标
            const resx = c.x + (pt.x - c.x) * Math.cos(radians) - (pt.y - c.y) * Math.sin(radians);
            const resy = c.y + (pt.x - c.x) * Math.sin(radians) + (pt.y - c.y) * Math.cos(radians);
            return { x: resx, y: resy };  // 返回新的坐标点
        }

        canvas.addEventListener("pointerdown", function (event) {
            // 检查鼠标是否点击在移动点附近
            let dx = event.offsetX - pt.x;
            let dy = event.offsetY - pt.y;
            if (Math.sqrt(dx * dx + dy * dy) < 30) {
                dragging = true;
            }
        });

        canvas.addEventListener('pointermove', (event) => {
            event.preventDefault(); // 防止默认行为
            if (dragging) {
                angle = -Math.atan2(event.offsetY - circ.y, event.offsetX - circ.x) * 180 / Math.PI;
                angle = ((angle - angle0) % 360 + 360) % 360 + angle0;
                angle = Math.round(angle * 10) / 10;
                if (angle - angle0 < 360 && angle - angle0 > 270) angle = angle0;
                if (angle - angle0 > 180 && angle - angle0 < 270) angle = angle0 + 180;
                p.textContent = dragging + ' moving';
            }
            draw(); // 重绘
        });

        canvas.addEventListener('pointerup', (event) => {
            p.textContent = dragging + ' up0';
            dragging = false;
            p.textContent = dragging + ' up1';
            window.alert('up');
        });

        canvas.addEventListener('pointerleave', (event) => {
            p.textContent = dragging + ' leave0'
            dragging = false;
            p.textContent = dragging + ' leave1';
        });

        canvas.addEventListener('pointerout', (event) => {
            p.textContent = dragging + ' out0'
            dragging = false;
            p.textContent = dragging + ' out1';
        });

        // 初始化绘制
        draw();



    </script>
</body>

</html>
