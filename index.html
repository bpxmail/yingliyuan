<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1/4桥</title>
    <style>
        canvas {
            touch-action: none;
            border: 1px solid black;
            position: absolute;
        }

        #canvasbg {
            z-index: 1;
        }

        #canvasline {
            z-index: 2;
        }

        p {
            width: 330px;
            text-indent: 2em;
        }
    </style>
</head>

<body>
    <div id="div1">
        <canvas id="canvasbg">canvas not supported</canvas>
        <canvas id="canvasline">canvas not supported</canvas>
    </div>
    <p id="pid">α-β-γ-δ-ε-ζ-η-θ-ι-κ-λ-μ-ν-ξ-ο-π-ρ-σ-τ-υ-φ-χ-ψ-ω</p>

    <script>
        let canvasbg = document.getElementById("canvasbg");
        let canvasline = document.getElementById("canvasline");
        let ctxbg = canvasbg.getContext("2d");
        let ctxline = canvasline.getContext("2d");
        let p = document.getElementById("pid");
        let div1 = document.getElementById("div1");

        // 画布大小
        let w = 0;
        let h = 0;
        initbg(); // 初始化背景画布大小和内容
        let pt0 = { x: -1, y: -1 }; //用于pointermove绘制直线的开始点
        let pt1 = { x: -1, y: -1 }; //用于pointermove绘制直线的结束点
        let pts0 = []; // 已连接的线段的起点数组
        let pts1 = []; // 已连接的线段的终点数组
        let index0 = -1; // 当前正在连接的线段的索引///////////////////////////////
        let index1 = -1;

        // 0是工作片左点，1是工作片右点
        // 2是白线补偿片左点，3是白线补偿片右点
        // 4是黑线补偿片左点，5是黑线补偿片右点
        let ptup = Array.from({ length: 6 }, () => ({ x: 0, y: 0 }));
        ptup[0] = { x: 140 / 833 * w, y: 253 / 788 * h };
        ptup[1] = { x: 255 / 833 * w, y: 253 / 788 * h };
        ptup[2] = { x: 551 / 833 * w, y: 253 / 788 * h };
        ptup[3] = { x: 633 / 833 * w, y: 253 / 788 * h };
        ptup[4] = { x: 699 / 833 * w, y: 253 / 788 * h };
        ptup[5] = { x: 773 / 833 * w, y: 253 / 788 * h };
        let ptdown = [];
        for (let j = 0; j <= 3; j++) { // 第j个通道
            ptdown[j] = [];
            for (let i = 0; i <= 4; i++) { //第i个接线柱
                ptdown[j][i] = { x: 0, y: 0 };
            }
        }
        // // 11-15是1号工作通道的5个接线点
        ptdown[0] = { x: 140 / 833 * w, y: 432 / 788 * h };
        ptdown[1] = { x: 140 / 833 * w, y: 496 / 788 * h };
        ptdown[2] = { x: 140 / 833 * w, y: 560 / 788 * h };
        ptdown[3] = { x: 140 / 833 * w, y: 624 / 788 * h };
        ptdown[4] = { x: 140 / 833 * w, y: 688 / 788 * h };
        // 21-25是2号工作通道的5个接线点
        ptdown[5] = { x: 337 / 833 * w, y: 432 / 788 * h };
        ptdown[6] = { x: 337 / 833 * w, y: 496 / 788 * h };
        ptdown[7] = { x: 337 / 833 * w, y: 560 / 788 * h };
        ptdown[8] = { x: 337 / 833 * w, y: 624 / 788 * h };
        ptdown[9] = { x: 337 / 833 * w, y: 688 / 788 * h };
        // 31-35是3号工作通道的5个接线点
        ptdown[10] = { x: 535 / 833 * w, y: 432 / 788 * h };
        ptdown[11] = { x: 535 / 833 * w, y: 496 / 788 * h };
        ptdown[12] = { x: 535 / 833 * w, y: 560 / 788 * h };
        ptdown[13] = { x: 535 / 833 * w, y: 624 / 788 * h };
        ptdown[14] = { x: 535 / 833 * w, y: 688 / 788 * h };
        // 41-45是4号补偿通道的5个接线点
        ptdown[15] = { x: 698 / 833 * w, y: 432 / 788 * h };
        ptdown[16] = { x: 698 / 833 * w, y: 496 / 788 * h };
        ptdown[17] = { x: 698 / 833 * w, y: 560 / 788 * h };
        ptdown[18] = { x: 698 / 833 * w, y: 624 / 788 * h };
        ptdown[19] = { x: 698 / 833 * w, y: 688 / 788 * h };
        let dragging = false; // 鼠标是否正在拖动





        draw();



        function draw() {
            ctxline.clearRect(0, 0, w, h);

            ctxline.strokeStyle = "rgb(237, 67, 120)";
            ctxline.lineWidth = 2;
            ctxline.beginPath();
            ctxline.stroke();
            for (let i = 0; i < pts0.length; i++) {
                ctxline.beginPath();
                ctxline.moveTo(pts0[i].x, pts0[i].y);
                ctxline.lineTo(pts1[i].x, pts1[i].y);
                ctxline.stroke();
            }

        }

        // 判断点(x, y)是否在pt附近
        function isptnear(x, y, pt) {
            let dx = x - pt.x;
            let dy = y - pt.y;
            return Math.sqrt(dx * dx + dy * dy) < 10;
        }

        // 判断pt0和pt1的连线是否允许
        // 禁止的连线包括：ptup内部连线，ptdown内部连线（只允许BB1,D1D2,D2D3）
        function islinelegal() {
            if (ptindex0 == ptindex1) return true;
            // 确保ptindex0 < ptindex1
            if(ptindex0 < ptindex1){
                let tmp = ptindex0;
                ptindex0 = ptindex1;
                ptindex1 = tmp;
            }
        }

        // 判断当前设备是否为移动设备
        function isMobile() {
            const userAgent = navigator.userAgent.toLowerCase();
            return /iphone|ipod|android|blackberry|windows phone|mobile/i.test(userAgent);
        }

        // 判断当前设备是否为横屏
        function isLandscape() {
            return window.orientation === 90 || window.orientation === -90;
        }

        // 根据设备类型初始化背景画布大小和内容
        function initbg() {
            if (!isMobile()) {
                canvasbg.width = 500;
                p.textContent = 'PC-' + canvasbg.width;
            }
            else if (isLandscape()) {
                canvasbg.width = 300;
                p.textContent = '横屏-' + canvasbg.width;
            }
            else {
                canvasbg.width = 330;
                p.textContent = '竖屏-' + canvasbg.width;
            }
            canvasbg.height = Math.round(canvasbg.width * 788 / 833);
            div1.style.width = canvasbg.width + "px";
            div1.style.height = canvasbg.height + "px";
            canvasline.width = canvasbg.width;
            canvasline.height = canvasbg.height;
            w = canvasbg.width;
            h = canvasbg.height;

            // 重新获取上下文
            ctxbg = canvasbg.getContext("2d");
            ctxline = canvasline.getContext("2d");

            // 重新绘制内容
            let imgbg = new Image();
            imgbg.src = "./images/qiaolu1.png";
            imgbg.onerror = function () {
                window.alert("Image not found. Please check the path: ./images/qiaolu1.png");
            };
            imgbg.onload = function () {
                ctxbg.drawImage(imgbg, 0, 0, canvasbg.width, canvasbg.height);
                // 初始绘制各个节点
                ctxbg.fillStyle = "rgb(237, 67, 120)";
                ctxbg.shadowColor = "rgb(0, 255, 0)";
                ctxbg.shadowBlur = 10;
                for (let i = 0; i <= 5; i++) {
                    ctxbg.beginPath();
                    ctxbg.arc(ptup[i].x, ptup[i].y, 5, 0, 2 * Math.PI);
                    ctxbg.fill();
                }
                for (i = 0; i <= 19; i++) {
                    ctxbg.beginPath();
                    ctxbg.arc(ptdown[i].x, ptdown[i].y, 5, 0, 2 * Math.PI);
                    ctxbg.fill();
                }

            };
        }

        // 监听窗口朝向变化
        window.addEventListener("orientationchange", initbg);

        canvasline.addEventListener("pointerdown", function (event) {
            if (dragging) return;
            for (let i = 0; i <= 5; i++) {
                if (isptnear(event.offsetX, event.offsetY, ptup[i])) {
                    dragging = true;
                    pt0 = ptup[i];
                    ptindex0 = i * 20;
                    return;
                }
            }
            for (let i = 0; i <= 19; i++) {
                if (isptnear(event.offsetX, event.offsetY, ptdown[i])) {
                    dragging = true;
                    pt0 = ptdown[i];
                    ptindex0 = i;
                    return;
                }
            }
        });

        canvasline.addEventListener('pointermove', (event) => {
            ctxline.clearRect(0, 0, w, h);
            draw(); // 重绘
            if (dragging) {
                ctxline.strokeStyle = "rgb(237, 67, 120)";
                ctxline.beginPath();
                ctxline.moveTo(pt0.x, pt0.y);
                ctxline.lineTo(event.offsetX, event.offsetY);
                ctxline.stroke();
            }
            p.textContent = 'x=' + event.offsetX + ', y=' + event.offsetY;
        });

        canvasline.addEventListener('pointerup', (event) => {
            if (!dragging) return;
            for (let i = 0; i <= 5; i++) {
                if (isptnear(event.offsetX, event.offsetY, ptup[i])) {
                    dragging = false;
                    pt1 = ptup[i];
                    ptindex1 = i * 20;
                    pts0.push(pt0);
                    pts1.push(ptup[i]);
                    return;
                }
            }
            for (let i = 0; i <= 19; i++) {
                if (isptnear(event.offsetX, event.offsetY, ptdown[i])) {
                    dragging = false;
                    pt1 = ptdown[i];
                    ptindex1 = i;
                    pts0.push(pt0);
                    pts1.push(ptdown[i]);
                    return;
                }
            }
            // draw(); // 重绘
        });

    </script>
</body>

</html>
