<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1/4桥</title>
    <style>
        canvas {
            touch-action: none;
            border: 1px solid black;
            position: absolute;
        }

        #canvasbg {
            z-index: 1;
        }

        #canvasline {
            z-index: 2;
        }

        p {
            width: 330px;
            text-indent: 2em;
        }
    </style>
</head>

<body>
    <div id="div1">
        <canvas id="canvasbg">canvas not supported</canvas>
        <canvas id="canvasline">canvas not supported</canvas>
    </div>
    <p id="pid">α-β-γ-δ-ε-ζ-η-θ-ι-κ-λ-μ-ν-ξ-ο-π-ρ-σ-τ-υ-φ-χ-ψ-ω</p>

    <script>
        let canvasbg = document.getElementById("canvasbg");
        let canvasline = document.getElementById("canvasline");
        let ctxbg = canvasbg.getContext("2d");
        let ctxline = canvasline.getContext("2d");
        let p = document.getElementById("pid");
        let div1 = document.getElementById("div1");

        // 画布大小
        let w = 0;
        let h = 0;
        initbg(); // 初始化背景画布大小和内容
        let pt0 = { x: 0, y: 0 }; //用于pointermove绘制直线的开始点
        let pt1 = { x: 0, y: 0 }; //用于pointermove绘制直线的结束点

        // 0是工作片左点，1是工作片右点
        // 2是白线补偿片左点，3是白线补偿片右点
        // 4是黑线补偿片左点，5是黑线补偿片右点
        let ptup = Array.from({ length: 6 }, () => ({ x: 0, y: 0 }));
        ptup[0] = { x: 140 / 833 * w, y: 253 / 788 * h };
        ptup[1] = { x: 255 / 833 * w, y: 253 / 788 * h };
        ptup[2] = { x: 551 / 833 * w, y: 253 / 788 * h };
        ptup[3] = { x: 633 / 833 * w, y: 253 / 788 * h };
        ptup[4] = { x: 699 / 833 * w, y: 253 / 788 * h };
        ptup[5] = { x: 773 / 833 * w, y: 253 / 788 * h };
        let ptdown = [];
        for (let j = 0; j <= 3; j++) { // 第j个通道
            ptdown[j] = [];
            for (let i = 0; i <= 4; i++) { //第i个接线柱
                ptdown[j][i] = { x: 0, y: 0 };
            }
        }
        // // 11-15是1号工作通道的5个接线点
        ptdown[0][0] = { x: 140 / 833 * w, y: 432 / 788 * h };
        ptdown[0][1] = { x: 140 / 833 * w, y: 496 / 788 * h };
        ptdown[0][2] = { x: 140 / 833 * w, y: 560 / 788 * h };
        ptdown[0][3] = { x: 140 / 833 * w, y: 624 / 788 * h };
        ptdown[0][4] = { x: 140 / 833 * w, y: 688 / 788 * h };
        // 21-25是2号工作通道的5个接线点
        ptdown[1][0] = { x: 337 / 833 * w, y: 432 / 788 * h };
        ptdown[1][1] = { x: 337 / 833 * w, y: 496 / 788 * h };
        ptdown[1][2] = { x: 337 / 833 * w, y: 560 / 788 * h };
        ptdown[1][3] = { x: 337 / 833 * w, y: 624 / 788 * h };
        ptdown[1][4] = { x: 337 / 833 * w, y: 688 / 788 * h };
        // 31-35是3号工作通道的5个接线点
        ptdown[2][0] = { x: 535 / 833 * w, y: 432 / 788 * h };
        ptdown[2][1] = { x: 535 / 833 * w, y: 496 / 788 * h };
        ptdown[2][2] = { x: 535 / 833 * w, y: 560 / 788 * h };
        ptdown[2][3] = { x: 535 / 833 * w, y: 624 / 788 * h };
        ptdown[2][4] = { x: 535 / 833 * w, y: 688 / 788 * h };
        // 41-45是4号补偿通道的5个接线点
        ptdown[3][0] = { x: 698 / 833 * w, y: 432 / 788 * h };
        ptdown[3][1] = { x: 698 / 833 * w, y: 496 / 788 * h };
        ptdown[3][2] = { x: 698 / 833 * w, y: 560 / 788 * h };
        ptdown[3][3] = { x: 698 / 833 * w, y: 624 / 788 * h };
        ptdown[3][4] = { x: 698 / 833 * w, y: 688 / 788 * h };
        let dragging = false; // 鼠标是否正在拖动





        draw();



        function draw() {
            ctxline.clearRect(0, 0, w, h);

            ctxline.strokeStyle = "rgb(237, 67, 120)";
            ctxline.lineWidth = 2;
            ctxline.beginPath();
            ctxline.moveTo(ptdown[0][0].x, ptdown[0][0].y);
            ctxline.lineTo(ptup[0].x, ptup[0].y);
            ctxline.stroke();

        }

        // 判断点(x, y)是否在pt附近
        function isptnear(x, y, pt) {
            let dx = x - pt.x;
            let dy = y - pt.y;
            return Math.sqrt(dx * dx + dy * dy) < 10;
        }

        // 判断当前设备是否为移动设备
        function isMobile() {
            const userAgent = navigator.userAgent.toLowerCase();
            return /iphone|ipod|android|blackberry|windows phone|mobile/i.test(userAgent);
        }

        // 判断当前设备是否为横屏
        function isLandscape() {
            return window.orientation === 90 || window.orientation === -90;
        }

        // 根据设备类型初始化背景画布大小和内容
        function initbg() {
            if (!isMobile()) {
                canvasbg.width = 500;
                p.textContent = 'PC-' + canvasbg.width;
            }
            else if (isLandscape()) {
                canvasbg.width = 300;
                p.textContent = '横屏-' + canvasbg.width;
            }
            else {
                canvasbg.width = 330;
                p.textContent = '竖屏-' + canvasbg.width;
            }
            canvasbg.height = Math.round(canvasbg.width * 788 / 833);
            div1.style.width = canvasbg.width + "px";
            div1.style.height = canvasbg.height + "px";
            canvasline.width = canvasbg.width;
            canvasline.height = canvasbg.height;
            w = canvasbg.width;
            h = canvasbg.height;

            // 重新获取上下文
            ctxbg = canvasbg.getContext("2d");
            ctxline = canvasline.getContext("2d");

            // 重新绘制内容
            let imgbg = new Image();
            imgbg.src = "./images/qiaolu1.png";
            imgbg.onerror = function () {
                window.alert("Image not found. Please check the path: ./images/qiaolu1.png");
            };
            imgbg.onload = function () {
                ctxbg.drawImage(imgbg, 0, 0, canvasbg.width, canvasbg.height);
                // 初始绘制各个节点
                ctxbg.fillStyle = "rgb(237, 67, 120)";
                ctxbg.shadowColor = "rgb(0, 255, 0)";
                ctxbg.shadowBlur = 10;
                for (let i = 0; i <= 5; i++) {
                    ctxbg.beginPath();
                    ctxbg.arc(ptup[i].x, ptup[i].y, 5, 0, 2 * Math.PI);
                    ctxbg.fill();
                }
                for (let j = 0; j <= 3; j++) {
                    for (let i = 0; i <= 4; i++) {
                        ctxbg.beginPath();
                        ctxbg.arc(ptdown[j][i].x, ptdown[j][i].y, 5, 0, 2 * Math.PI);
                        ctxbg.fill();
                    }
                }

            };
        }

        // 监听窗口朝向变化
        window.addEventListener("orientationchange", initbg);

        canvasline.addEventListener("pointerdown", function (event) {
            if(dragging) return;
            for (let i = 0; i <= 5; i++) {
                if (isptnear(event.offsetX, event.offsetY, ptup[i])) {
                    dragging = true;
                    pt0 = ptup[i];
                    return;
                }
            }
            for (let j = 0; j <= 3; j++) {
                for (let i = 0; i <= 4; i++) {
                    if (isptnear(event.offsetX, event.offsetY, ptdown[j][i])) {
                        dragging = true;
                        pt0 = ptdown[j][i];
                        return;
                    }
                }
            }
        });

        canvasline.addEventListener('pointermove', (event) => {
            // event.preventDefault(); // 防止默认行为
            // if (dragging) {
            //     angle = -Math.atan2(event.offsetY - circ.y, event.offsetX - circ.x) * 180 / Math.PI;
            //     angle = ((angle - angle0) % 360 + 360) % 360 + angle0;
            //     angle = Math.round(angle * 10) / 10;
            // }
            
            ctxline.clearRect(0, 0, w, h);
            draw(); // 重绘
            ctxline.strokeStyle = "rgb(237, 67, 120)";
            ctxline.beginPath();
            ctxline.moveTo(pt0.x, pt0.y);
            ctxline.lineTo(event.offsetX, event.offsetY);
            // ctxline.moveTo(0,0);
            // ctxline.lineTo(100,100);
            ctxline.stroke();
            p.textContent = 'x=' + event.offsetX + ', y=' + event.offsetY;
        });

        canvaslinea.ddEventListener('pointerup', (event) => {
            // dragging = false;
            draw(); // 重绘
        });

        canvasline.addEventListener('pointerleave', (event) => {
            // dragging = false;
            draw(); // 重绘
        });
    </script>
</body>

</html>
