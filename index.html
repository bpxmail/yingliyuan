<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1/4桥</title>
    <style>
        canvas {
            touch-action: none;
            border: 1px solid black;
            position: absolute;
        }

        #canvasbg {
            z-index: 1;
        }

        #canvasline {
            z-index: 2;
        }

        p {
            width: 330px;
            text-indent: 2em;
        }
    </style>
</head>

<body>
    <div id="div1">
        <canvas id="canvasbg">canvas not supported</canvas>
        <canvas id="canvasline">canvas not supported</canvas>
    </div>
    <p id="pid">α-β-γ-δ-ε-ζ-η-θ-ι-κ-λ-μ-ν-ξ-ο-π-ρ-σ-τ-υ-φ-χ-ψ-ω</p>

    <script>
        let canvasbg = document.getElementById("canvasbg");
        let canvasline = document.getElementById("canvasline");
        let ctxbg = canvasbg.getContext("2d");
        let ctxline = canvasline.getContext("2d");
        let p = document.getElementById("pid");
        let div1 = document.getElementById("div1");

        // 画布大小
        let w = 0;
        let h = 0;
        initbg(); // 初始化背景画布大小和内容
        let dragging = false; // 鼠标是否正在拖动
        let ptindex = -1; // 已按下的线段第一个点的索引值
        let ptindexbd = [1, 2, 6, 7, 11, 12, 17, 18, 19]; // 下边可以连接的点的索引值，包括所有的B和D
        let lines = []; // 已连接的线段数组，由线段两个点的索引值相加组成
        // let isupused = [false, false, false, false, false, false]; // 上边的点是否已经连接线段
        let isupused = Array.from({ length: 6 }, () => (false)); // 上边的点是否已经连接线段

        // 上边6个接线点，索引值分别为40, 60, 80, 100, 120, 140
        let ptup = Array.from({ length: 6 }, () => ({ x: 0, y: 0 }));
        ptup[0] = { x: 140 / 833 * w, y: 253 / 788 * h };
        ptup[1] = { x: 255 / 833 * w, y: 253 / 788 * h };
        ptup[2] = { x: 551 / 833 * w, y: 253 / 788 * h };
        ptup[3] = { x: 633 / 833 * w, y: 253 / 788 * h };
        ptup[4] = { x: 699 / 833 * w, y: 253 / 788 * h };
        ptup[5] = { x: 773 / 833 * w, y: 253 / 788 * h };
        for (let i = 0; i < 6; i++) {
            ptup[i].x = Math.round(ptup[i].x);
            ptup[i].y = Math.round(ptup[i].y);
        }
        // 下边的20个接线点，索引值分别为0~19
        let ptdown = Array.from({ length: 20 }, () => ({ x: 0, y: 0 }));
        // 0-4是1号工作通道的5个接线点
        ptdown[0] = { x: Math.round(140 / 833 * w), y: Math.round(432 / 788 * h) };
        ptdown[1] = { x: 140 / 833 * w, y: 496 / 788 * h };
        ptdown[2] = { x: 140 / 833 * w, y: 560 / 788 * h };
        ptdown[3] = { x: 140 / 833 * w, y: 624 / 788 * h };
        ptdown[4] = { x: 140 / 833 * w, y: 688 / 788 * h };
        // 5-9是2号工作通道的5个接线点
        ptdown[5] = { x: 337 / 833 * w, y: 432 / 788 * h };
        ptdown[6] = { x: 337 / 833 * w, y: 496 / 788 * h };
        ptdown[7] = { x: 337 / 833 * w, y: 560 / 788 * h };
        ptdown[8] = { x: 337 / 833 * w, y: 624 / 788 * h };
        ptdown[9] = { x: 337 / 833 * w, y: 688 / 788 * h };
        // 10-14是3号工作通道的5个接线点
        ptdown[10] = { x: 535 / 833 * w, y: 432 / 788 * h };
        ptdown[11] = { x: 535 / 833 * w, y: 496 / 788 * h };
        ptdown[12] = { x: 535 / 833 * w, y: 560 / 788 * h };
        ptdown[13] = { x: 535 / 833 * w, y: 624 / 788 * h };
        ptdown[14] = { x: 535 / 833 * w, y: 688 / 788 * h };
        // 15-19是4号补偿通道的5个接线点
        ptdown[15] = { x: 698 / 833 * w, y: 432 / 788 * h };
        ptdown[16] = { x: 698 / 833 * w, y: 496 / 788 * h };
        ptdown[17] = { x: 698 / 833 * w, y: 560 / 788 * h };
        ptdown[18] = { x: 698 / 833 * w, y: 624 / 788 * h };
        ptdown[19] = { x: 698 / 833 * w, y: 688 / 788 * h };
        for (let i = 0; i < 20; i++) {
            ptdown[i].x = Math.round(ptdown[i].x);
            ptdown[i].y = Math.round(ptdown[i].y);
        }





        draw();



        function draw() {
            ctxline.clearRect(0, 0, w, h);

            let ptstart, ptend;
            ctxline.strokeStyle = "rgb(237, 67, 120)";
            ctxline.lineWidth = 2;
            for (let i = 0; i < lines.length; i++) {
                ctxline.beginPath();
                [ptstart, ptend] = index2line(lines[i]);
                ctxline.moveTo(ptstart.x, ptstart.y);
                ctxline.lineTo(ptend.x, ptend.y);
                ctxline.stroke();
            }

        }

        // 判断点(x, y)是否在pt附近
        function isptnear(x, y, pt) {
            let dx = x - pt.x;
            let dy = y - pt.y;
            return Math.sqrt(dx * dx + dy * dy) < 10;
        }

        // 判断连线是否允许，上边点索引值为20:20:120，下边点为0:19
        // 返回-1表示非法连线，返回非负数表示两个点的位置
        // 禁止的连线包括：ptup内部连线，ptdown内部连线（只允许BB1,D1D2,D2D3）
        function islinelegal(t0, t1) {
            // 确保n0 > n1，n0是上面的点，n1是下面的点
            let tmp, n0 = t0, n1 = t1;
            if (n0 < n1) {
                tmp = n0;
                n0 = n1;
                n1 = tmp;
            }
            tmp = n0 + n1;
            // 非法，都是上边的点，ptup内部连线
            if ((n1 > 0) && (n1 % 20 === 0)) return -1;
            // 都是下边的点
            if (n0 < 20) {
                if (n0 === 2 && n1 === 1) return tmp; // BB1
                if (n0 === 7 && n1 === 6) return tmp; // BB1
                if (n0 === 12 && n1 === 11) return tmp; // BB1
                if (n0 === 18 && n1 === 17) return tmp; // D1D2
                if (n0 === 19 && n1 === 18) return tmp; // D2D3
                return -1; // 下边其他的点
            }
            // 合法，上边和下边的点
            return tmp;
        }

        // 从索引值获得点的坐标
        function index2pt(index) {
            if (index >= 40) return ptup[index / 20 - 2];
            else if (index >= 0 && index <= 19) return ptdown[index];
            else return { x: -1, y: -1 };
        }

        // 从索引值之和获得线段两点的坐标
        function index2line(index) {
            switch (index) {
                case 3:
                    return [ptdown[1], ptdown[2]];
                case 13:
                    return [ptdown[6], ptdown[7]];
                case 23:
                    return [ptdown[11], ptdown[12]];
                case 35:
                    return [ptdown[17], ptdown[18]];
                case 37:
                    return [ptdown[18], ptdown[19]];
                default:
                    let t1 = index % 20;
                    let t0 = index - t1;
                    return [index2pt(t0), index2pt(t1)];

            }
        }

        // 判断当前设备是否为移动设备
        function isMobile() {
            const userAgent = navigator.userAgent.toLowerCase();
            return /iphone|ipod|android|blackberry|windows phone|mobile/i.test(userAgent);
        }

        // 判断当前设备是否为横屏
        function isLandscape() {
            return window.orientation === 90 || window.orientation === -90;
        }

        // 根据设备类型初始化背景画布大小和内容
        function initbg() {
            if (!isMobile()) {
                canvasbg.width = 500;
                p.textContent = 'PC-' + canvasbg.width;
            }
            else if (isLandscape()) {
                canvasbg.width = 300;
                p.textContent = '横屏-' + canvasbg.width;
            }
            else {
                canvasbg.width = 330;
                p.textContent = '竖屏-' + canvasbg.width;
            }
            canvasbg.height = Math.round(canvasbg.width * 788 / 833);
            div1.style.width = canvasbg.width + "px";
            div1.style.height = canvasbg.height + "px";
            canvasline.width = canvasbg.width;
            canvasline.height = canvasbg.height;
            w = canvasbg.width;
            h = canvasbg.height;

            // 重新获取上下文
            ctxbg = canvasbg.getContext("2d");
            ctxline = canvasline.getContext("2d");

            // 重新绘制内容
            let imgbg = new Image();
            imgbg.src = "./images/qiaolu1.png";
            imgbg.onerror = function () {
                window.alert("Image not found. Please check the path: ./images/qiaolu1.png");
            };
            imgbg.onload = function () {
                ctxbg.drawImage(imgbg, 0, 0, canvasbg.width, canvasbg.height);
                // 初始绘制各个节点
                ctxbg.fillStyle = "rgb(237, 67, 120)";
                ctxbg.shadowColor = "rgb(0, 255, 0)";
                ctxbg.shadowBlur = 10;
                for (let i = 0; i <= 5; i++) {
                    ctxbg.beginPath();
                    ctxbg.arc(ptup[i].x, ptup[i].y, 5, 0, 2 * Math.PI);
                    ctxbg.fill();
                }
                for (i = 0; i <= 19; i++) {
                    ctxbg.beginPath();
                    ctxbg.arc(ptdown[i].x, ptdown[i].y, 5, 0, 2 * Math.PI);
                    ctxbg.fill();
                }

            };
        }

        // 监听窗口朝向变化
        window.addEventListener("orientationchange", initbg);

        canvasline.addEventListener("pointerdown", function (event) {
            if (dragging) return;
            for (let i = 0; i <= 5; i++) {
                if (isptnear(event.offsetX, event.offsetY, ptup[i])) {
                    dragging = true;
                    ptindex = (i + 2) * 20;
                    return;
                }
            }
            for (let i = 0; i <= 8; i++) {
                if (isptnear(event.offsetX, event.offsetY, ptdown[ptindexbd[i]])) {
                    dragging = true;
                    ptindex = ptindexbd[i];
                    return;
                }
            }
        });

        canvasline.addEventListener('pointermove', (event) => {
            ctxline.clearRect(0, 0, w, h);
            draw(); // 重绘
            if (dragging) {
                ctxline.strokeStyle = "rgb(237, 67, 120)";
                ctxline.beginPath();
                ctxline.moveTo(index2pt(ptindex).x, index2pt(ptindex).y);
                ctxline.lineTo(event.offsetX, event.offsetY);
                ctxline.stroke();
            }
            // p.textContent = 'x=' + event.offsetX + ', y=' + event.offsetY;
            p.innerHTML = 'pointer move line length = ' + lines.length;
        });

        canvasline.addEventListener('pointerup', (event) => {
            if (!dragging) return;
            dragging = false;
            for (let i = 0; i <= 19; i++) {
                if (isptnear(event.offsetX, event.offsetY, ptdown[i])) {
                    if (islinelegal(ptindex, i) < 0) return;  // 当前线段不合法
                    if (ptindex < 20) { // 针对下边的BD点
                        if (lines.indexOf(ptindex + i) < 0) lines.push(ptindex + i);
                        else lines.splice(lines.indexOf(ptindex + i), 1);
                        return;
                    }
                    // 上边的点还没有占用，当前线段加入lines
                    if (!isupused[ptindex / 20 - 2]) {
                        lines.push(ptindex + i);
                        isupused[ptindex / 20 - 2] = true;
                    }
                    // 当前线段在lines里，则从lines里删除
                    else if (lines.indexOf(ptindex + i) >= 0) {
                        lines.splice(lines.indexOf(ptindex + i), 1);
                        isupused[ptindex / 20 - 2] = false;
                    }
                    // 上边的点已经占用
                    else
                        return;
                }
            }
            // draw(); // 重绘
        });

        canvasline.addEventListener('pointerleave', (event) => {
            dragging = false;
            draw();
        });

    </script>
</body>

</html>
