<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>应力圆</title>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
</head>

<body>
    <canvas id="canvasid" width="500" height="600">canvas not supported</canvas>
    <p id="pid">debug-σ</p>
    <script>
        var canvas = document.getElementById("canvasid");
        var ctx = canvas.getContext("2d");
        var p = document.getElementById("pid");

        var axis_x_start = { x: 50, y: 150 };
        var axis_x_end = { x: 450, y: 150 };
        var axis_y_start = { x: 150, y: 250 };
        var axis_y_end = { x: 150, y: 50 };
        var center = { x: 300, y: axis_x_start.y };
        var arrow = 10; // 箭头大小
        var r = 100; // 半径

        // 鼠标拖动功能
        let dragging = false;
        // 初始角度
        let angle0 = 30;
        let angle = 30;
        let pt = { x: 0, y: 0 }; // 移动点
        pt.x = center.x + r * Math.cos(-angle * Math.PI / 180);
        pt.y = center.y + r * Math.sin(-angle * Math.PI / 180);

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // 清除画布
            ctx.font = "bolder 20px 'Times New Roman'";
            ctx.fillText("请拖动红点以观察不同角度斜面上的应力", 70, 20);
            ctx.font = "bolder italic 20px 'Times New Roman'";
            ctx.lineWidth = 2;

            // 绘制坐标轴
            ctx.beginPath();
            ctx.moveTo(axis_x_start.x, axis_x_start.y);
            ctx.lineTo(axis_x_end.x, axis_x_end.y);
            ctx.moveTo(axis_y_start.x, axis_y_start.y);
            ctx.lineTo(axis_y_end.x, axis_y_end.y);
            ctx.stroke();
            // 绘制箭头
            drawarrow(axis_x_end, arrow, 4);
            drawarrow(axis_y_end, arrow, 1);
            // 绘制坐标轴文字
            ctx.fillText("σ", axis_x_end.x - 10, axis_x_end.y + 20);
            ctx.fillText("τ", axis_y_end.x + 10, axis_y_end.y + 10);
            ctx.fillText("2α0", center.x + r / 2, center.y - r / 12);
            if (angle != angle0) ctx.fillText("2α", center.x + r / 4, center.y - r / 4);
            // 绘制圆
            ctx.beginPath();
            ctx.arc(center.x, center.y, r, 0, 2 * Math.PI);
            ctx.stroke();
            // 绘制圆弧1
            ctx.beginPath();
            ctx.arc(center.x, center.y, r / 4, 0, -angle0 * Math.PI / 180, true);
            ctx.stroke();
            // 绘制圆弧2
            ctx.beginPath();
            ctx.arc(center.x, center.y, r / 3, -angle0 * Math.PI / 180, -angle * Math.PI / 180, true);
            ctx.stroke();
            // 绘制虚线
            ctx.beginPath();
            ctx.save();
            ctx.strokeStyle = 'green';
            ctx.setLineDash([6, 6]);
            ctx.moveTo(center.x - r * Math.cos(-angle0 * Math.PI / 180),
                center.y - r * Math.sin(-angle0 * Math.PI / 180));
            ctx.lineTo(center.x + r * Math.cos(-angle0 * Math.PI / 180),
                center.y + r * Math.sin(-angle0 * Math.PI / 180));
            ctx.stroke();
            ctx.restore();
            // 绘制移动虚线
            ctx.beginPath();
            ctx.save();
            ctx.setLineDash([3, 5]);
            ctx.moveTo(pt.x, axis_x_start.y);
            ctx.lineTo(pt.x, pt.y);
            ctx.lineTo(axis_y_start.x, pt.y);
            ctx.stroke();
            ctx.restore();
            ctx.beginPath();
            pt.x = center.x + r * Math.cos(-angle * Math.PI / 180);
            pt.y = center.y + r * Math.sin(-angle * Math.PI / 180);
            ctx.moveTo(center.x, center.y);
            ctx.lineTo(pt.x, pt.y);
            ctx.stroke();
            // 绘制移动点
            ctx.beginPath();
            ctx.arc(pt.x, pt.y, 5, 0, 2 * Math.PI);
            ctx.save();
            ctx.fillStyle = 'red';
            if (dragging) { ctx.shadowBlur = 10; ctx.shadowColor = 'navy'; }
            ctx.fill();
            ctx.restore();

            let squsize = 180; // 单元体大小
            let squcenter = { x: canvas.width / 2, y: axis_x_start.y + 300 };
            // 绘制单元体
            ctx.beginPath();
            ctx.moveTo(squcenter.x - squsize / 2, squcenter.y - squsize / 2);
            ctx.lineTo(squcenter.x + squsize / 2, squcenter.y - squsize / 2);
            ctx.lineTo(squcenter.x + squsize / 2, squcenter.y + squsize / 2);
            ctx.lineTo(squcenter.x - squsize / 2, squcenter.y + squsize / 2);
            ctx.closePath();
            ctx.stroke();
            // 绘制坐标轴
            ctx.beginPath
            ctx.moveTo(squcenter.x, squcenter.y - squsize / 2);
            ctx.lineTo(squcenter.x, squcenter.y - squsize);
            ctx.moveTo(squcenter.x + squsize / 2, squcenter.y);
            ctx.lineTo(squcenter.x + squsize, squcenter.y);
            ctx.stroke();
            drawarrow({ x: squcenter.x, y: squcenter.y - squsize }, arrow, 1);
            drawarrow({ x: squcenter.x + squsize, y: squcenter.y }, arrow, 4);
            ctx.fillText("x", squcenter.x + squsize - 10, squcenter.y + 20);
            ctx.fillText("y", squcenter.x + 10, squcenter.y - squsize + 10);
            ctx.fillText("σx", squcenter.x + squsize * 3 / 4 - 20, squcenter.y + 20);
            ctx.fillText("σy", squcenter.x + 10, squcenter.y - squsize*3/4 + 10);
            // 绘制单元体应力及箭头
            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = 'rgb(0,150,150)';
            ctx.moveTo(squcenter.x - squsize / 2 - 10, squcenter.y - squsize / 4);
            ctx.lineTo(squcenter.x - squsize / 2 - 10, squcenter.y + squsize / 4);
            ctx.moveTo(squcenter.x + squsize / 2 + 10, squcenter.y - squsize / 4);
            ctx.lineTo(squcenter.x + squsize / 2 + 10, squcenter.y + squsize / 4);
            ctx.moveTo(squcenter.x - squsize / 4, squcenter.y - squsize / 2 - 10);
            ctx.lineTo(squcenter.x + squsize / 4, squcenter.y - squsize / 2 - 10);
            ctx.moveTo(squcenter.x - squsize / 4, squcenter.y + squsize / 2 + 10);
            ctx.lineTo(squcenter.x + squsize / 4, squcenter.y + squsize / 2 + 10);
            ctx.moveTo(squcenter.x - squsize / 2, squcenter.y);
            ctx.lineTo(squcenter.x - squsize * 3 / 4, squcenter.y);
            ctx.moveTo(squcenter.x + squsize / 2, squcenter.y);
            ctx.lineTo(squcenter.x + squsize * 3 / 4, squcenter.y);
            ctx.moveTo(squcenter.x, squcenter.y - squsize / 2);
            ctx.lineTo(squcenter.x, squcenter.y - squsize * 3 / 4);
            ctx.moveTo(squcenter.x, squcenter.y + squsize / 2);
            ctx.lineTo(squcenter.x, squcenter.y + squsize * 3 / 4);
            ctx.stroke();
            ctx.fillStyle = 'rgb(0,150,150)';
            drawarrow({ x: squcenter.x - squsize / 2 - 10, y: squcenter.y - squsize / 4 }, arrow, 1);
            drawarrow({ x: squcenter.x + squsize / 2 + 10, y: squcenter.y + squsize / 4 }, arrow, 2);
            drawarrow({ x: squcenter.x - squsize / 4, y: squcenter.y - squsize / 2 - 10 }, arrow, 3);
            drawarrow({ x: squcenter.x + squsize / 4, y: squcenter.y + squsize / 2 + 10 }, arrow, 4);
            drawarrow({ x: squcenter.x - squsize * 3 / 4, y: squcenter.y }, arrow, 3);
            drawarrow({ x: squcenter.x + squsize * 3 / 4, y: squcenter.y }, arrow, 4);
            drawarrow({ x: squcenter.x, y: squcenter.y - squsize * 3 / 4 }, arrow, 1);
            drawarrow({ x: squcenter.x, y: squcenter.y + squsize * 3 / 4 }, arrow, 2);
            ctx.restore();
        }

        // 绘制箭头，direction为绘制方向，1向上，2向下，3向左，4向右
        function drawarrow(pt, size, direction) {
            ctx.beginPath();
            ctx.moveTo(pt.x, pt.y);
            switch (direction) {
                case 1:
                    ctx.lineTo(pt.x - size / 2, pt.y + size);
                    ctx.lineTo(pt.x + size / 2, pt.y + size);
                    break;
                case 2:
                    ctx.lineTo(pt.x - size / 2, pt.y - size);
                    ctx.lineTo(pt.x + size / 2, pt.y - size);
                    break;
                case 3:
                    ctx.lineTo(pt.x + size, pt.y - size / 2);
                    ctx.lineTo(pt.x + size, pt.y + size / 2);
                    break;
                case 4:
                    ctx.lineTo(pt.x - size, pt.y - size / 2);
                    ctx.lineTo(pt.x - size, pt.y + size / 2);
                    break;
            }
            ctx.closePath
            ctx.fill();
        }

        canvas.addEventListener("mousedown", function (event) {
            // 检查鼠标是否点击在移动点附近
            let dx = event.offsetX - pt.x;
            let dy = event.offsetY - pt.y;
            if (Math.sqrt(dx * dx + dy * dy) < 10) {
                dragging = true;
            }
        });

        canvas.addEventListener('mousemove', (event) => {
            if (dragging) {
                angle = -Math.atan2(event.offsetY - center.y, event.offsetX - center.x) * 180 / Math.PI;
                angle = ((angle - angle0) % 360 + 360) % 360 + angle0;
                angle = Math.round(angle * 10) / 10;
                if (angle - angle0 < 360 && angle - angle0 > 270) angle = angle0;
                if (angle - angle0 > 180 && angle - angle0 < 270) angle = angle0 + 180;
            }
            draw(); // 重绘
            p.textContent = angle;
        });

        canvas.addEventListener('mouseup', (event) => {
            dragging = false;
        });

        canvas.addEventListener('mouseleave', (event) => {
            dragging = false;
        });

        // 初始化绘制
        draw();



    </script>
</body>

</html>
